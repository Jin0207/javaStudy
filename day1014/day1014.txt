<재귀호출>

메서드 안에서 자기자신을 반복적으로 호출하는 것
재귀호출 메서드를 만들 땐,
반드시 끝나는 조건이 필요하다.
없을 경우 계속 동작

q) n을 매개변수로 전달받아 n!을 구하여
   반환하는 메서드를 재귀호출을 이용하여 정의 해 보자.

public int getFactorial(int n){\
   if(n == 1){
     return 1; //메서드를 끝내고 반환한다. return!
   }
   return n * getFactorial(n-1);
}
=============================================================================
<클래스의 상속>

class 자손클래스이름 extends 조상클래스이름 

자손클래스가 부모클래스로부터 변수와 메서드를 상속받음
자손클래스만 추가적으로 갖는 변수와 메서드를 선언할 수도 있음

반복적으로 사용되는 변수와 메서드를
상속을 통하여 다시 작성할 필요가 없어짐
--> 코드의 재사용성

private 접근제어자로 정의된 속성과 기능은
상속으로는 접근이 불가능함 ( 자식클래스에서 접근할 수 없다)

자식클래스도 바로 접근할 수 있게 해주는
접근제어자 "protected"

클래스 계층구조에서
아주 꼭대기 조상 클래스는 Object 클래스

모든 클래스는 Object클래스로부터 상속받는다.

<상속과 생성자>

생성자를 만들면
객체생성시에 자동적으로 멤버변수들의 값들을 초기화시킬 수 있다.

만약,
상속관계에 있는 클래스의 객체를 생성한다면
부모클래스의 생성자 먼저 실행되고
그 다음에 자식클래스의 생성자가 실행된다.

<super()>
super는 조상클래스를 가리키는 키워드이다.
super()는 조상의 기본생성자를 호출한다는 의미이고
매개변수가 있는 생성자를 호출할 땐, 괄호안에 매개변수를 넣어준다.

자식의 기본생성자안에는 super(); 가 생략되어있다.

자식클래스에서
부모클래스의 동일한 메서드를 요청하기위해선
super.메서드명()으로 사용한다.

부모클래스가 가지고있는 멤버변수들은
부모가 직접 해결하도록 한다.


================================================================
<메서드 오버로딩 vs 메서드 오버라이딩>

메서드 오버로딩

메서드의
매개변수의 타입이나 개수가 다를 경우
똑같은 메서드이름으로 새로운 메서드를 정의하는 것

메서드 오버라이딩

자식클래스는 
부모로부터 상속된 변수 뿐만아니라
자기만의 변수도 갖고 있기에,
부모로부터 물려받은 메서드를 
자신에 맞게 수정하여 같은 이름으로 정의할 수 있다.
단, 메서드이름 뿐만아니라 반환타입, 매개변수의 개수 까지 일치해야한다.


