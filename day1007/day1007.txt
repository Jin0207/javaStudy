<배열>
같은 타입의 데이터들을 칸이 나뉘어있는 보관함에 넣어둔 것
이때 보관함의 타입 = 데이터들의 타입이어야 보관 가능

ex)
int[] a = new int[5]
-정수형 보관함 a는 5개의 칸을 갖는다

int[] a; //정수형 보관함 a를 만듦
-담을 수 있는 보관함을 만든 것이지 몇칸으로 나뉠지 모르니 a를 갖다 쓸 수 없음
a = new int[5];//보관함 a를 5칸으로 만들어줌
--칸을 만들어주는 동시에 각 칸에는 해당타입의 기본값을 넣어줌

 int[] a = {10,20,30,40,50}
 --보관함 a의 첫번째 칸에 10을 넣고
   두번째칸에는 20을 넣는다...
   총 5개의 칸이 만들어짐
----------------------------------------------------------------------------------
기본형 : 값을 저장하고 있는 자료형
int - 0
double - 0.0
boolean - false

참조형 : 참조하고있다.(가리키고있다) // 값을 가지고 있는게 아님
 - null
* 배열 : 참조형
ex) int[] a = {10, 20, 30, 40, 50}
    // { 10, 20, 30, 40, 50}이 보관된 곳의 주소가 1이라면
        a는 그 주소인 1을 가리키고 있는 것임
---------------------------------------------------------------------------------
<다차원 배열>

1)일차원 배열
   int[] a = new int[5]

2)이차원 배열
   int[][] a = new int[4][5]
  -- 4행 5열의 보관함이 생긴것
     총 20개의 데이터를 저장할 수 있는 공간이 생긴 것
     
     배열을 일괄처리하고자 한다면,
     중첩 반복문을 이용해야함.
     행을 위한 반복문 1개, 그 안에 열을 위한 반복문 1개

     행의 길이: a.length, 열의 길이: a[해당행].length
     
3)삼차원 배열
  int[][][] a = new int[2][4][5]
 -- 큰 보관함을 일단 2개의 면으로 나누고
    각각 4행 5열로 나눈다.
----------------------------------------------------------------------------------
<배열의 단점>

1. 보관함의 타입(자료형) = 안의 데이터들의 타입
2. 크기가 고정되어 있음
eX) 
   int[] a = new int[5];
   5칸만을 가진 보관함, 이후에 더 넣을 수 없다.
   --몇개를 담아야할지 예측하기 어려운 경우 배열 사용 불편
     어떤 데이터들을 담을지 모르면 배열 사용 불편

<컬렉션 프레임워크>
-배열의 단점을 보완하기 위한 "향상된 배열"
----------------------------------------------------------------------------------
<메서드>
-특정 작업을 수행하는 일련의 문장들을 하나로 묶어 이름을 붙혀준 것
-메서드의 이름을 입력하면 메서드 안의 작업들을 사용할 수 있다.

* 반환타입 메서드이름(매개변수){
   //수행해야하는 작업들
  } // 매개변수는 배열을 가진 변수도 들어갈 수 있음

-메서드의 이름을 불러서
 메서드 안의 작업을 수행하고난뒤에는
 메서드의 이름을 불렀던 곳으로 돌아간다.

if)메서드 안의 작업을 다 끝내기 전에 
   되돌아 가게하기위한 명령어: return
   return을 만나면 호출한 곳으로 돌아감

-모든 메서드는 {}안에 return을 가지고 있음.
 {}안에 안 적혀있으면 }끝나기 직전에 return이 생략된 것
 생략된 경우는 {}안에서 호출한 곳으로 돌아갈 때 값을 안들고 가도 되는 경우 -- 반환타입은 void
 return이 있는 경우는 어떤 값을 들고 돌아가야할경우 return 가지고 갈 데이터
 가지고갈 데이터의 타입 = 반환타입 이어야한다.


-메서드 호출

1)static이 없다면
  객체를 생성해 놓고 해당 객체를 통해서 메서드를 호출

2)static이 있다면
  객체 생성없이 클래스이름을 통해서 메서드 호출

-하나의 파일 안에
 두개 이상의 클래스가 존재한다면
 메인메서드를 포함하는 클래스이름 = 파일명
