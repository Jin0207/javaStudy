<변수와 자료형>

1_변수 = 데이터 저장공간
: 프로그램 실행 중 발생하는 데이터를 저장하기 위한 메모리
   이 메모리를 확보하는 것을 “변수를 선언한다”고 함.

2_자료형
:저장공간(변수) 안에 어떤 타입의 자료를 저장할 것인지 지정해주는 것

  2_1 자료형의 종류
	1.기본자료형 - 8가지
	:  변수가 값을 가지고 있다 
	// 변수의 저장공간안에 값을 가지고 있다
		ex_기본자료형을 선언할시 자동초기화되는 기본값 	
		int - 0
		double - 0.0
		boolean - false

		1) 정수를 표현하는 자료형
			
			- byte = 1byte = 8bit 
			*표현범위: -127 ~ 128 ( -2의 7승 ~ -2의 7승 – 1) – 1bit: 부호비트
			
			- short = 2byte
			
			- int = 4byte *기본적으로 자바프로그램에 입력되는 정수는 int로 취급
			
			- long = 8byte

		2) 실수를 표현하는 자료형
			
			- float = 4byte
			
			- double = 8byte *기본적으로 자바프로그램에 입력되는 실수는 double로 취급
		
		3) 문자를 표현하는 자료형
			-char = 2byte  : ‘ ‘안에 작성 -- 1글자
		=>문자열(여러 문자 결합) 참조형 String – “ “ 안에 작성

		4) 논리를 표현하는 자료형
			- boolean = 1byte : 논리값 false | true를 저장할 수 있는 자료형	

		2. 참조자료형
			변수가 값을 가지고 있지 않다 
			값이 있는 곳을 참조하고 있다(가리키고 있다.)
			
			기본값 :  null
				
			* 배열 : 참조형 -- 객체생성시 안에 기본값들이 초기화됨
			
			ex) int[] a = new int[5]
			    // 모든 a 배열 안 요소 값들은 0을 지님
			    // int가 아니라 String일 경우엔 null

========================================================================================================

<연산자>
1.산술연산자 
	+, -, *, /(몫), %(나머지)
	
	-정수와 정수를 연산하면 결과는 정수값 반환
	
	-정수의 연산에서 실수값을 반환하고 싶다면 둘 중 하나를 형변환하여 연산한다. – ex) (double)a/b

	*형변환:
	- 변수타입의 표현범위를 넘어선 값을 저장할려고하면 값손실이 일어날 수 있음
	-overflow : 표현범위보다 더+ 된 값  ex) 표현범위보다 +1 된 경우: min값
	-underflow: 표현범위보다 더 -된 값 ex) 표현범위보다 -1 된 경우: max값
---------------------------------------------------------------------------------------------------------------------
2.	증감연산자
	-변수 (뒤/앞) 에 올 수 있다.
	
	-단독 사용시 결과 같음 -- ++i == i++
	
	-다른 연산자나 명령문에 사용 시 (앞/뒤) 에 따라 결과값 달라짐
		
		  --. 증감연산자 + 변수명
			ex) ++i
			변수의 증감 실행하고 다른 연산자나 명령문 수행
		
		 -- 변수명 + 증감연산자
		    ex) i++
		  다른 연산자나 명령문 수행 후 변수의 증감실행

	종류
	1. ++ 증가연산자
	: 변수 자신 + 1을 한 후 다시 변수에 대입하는 연산자
	
	2  -- 감소연산자
	: 변수 자신 – 1을 한 후 다시 변수에 대입하는 연산자
-----------------------------------------------------------------------------------------------------------

3.비교 연산자: 두개의 값을 서로 비교하기 위한 연산자들
	->, <, >=, <=, ==, !=
	
	-“공백없이” 기호와 기호를 붙혀 사용해야함 
	    ex)"> =" (x) --> ">="(o)
	-비교 연산의 결과는 Boolean 자료형 (true / false)
	-선택문의 조건식에 주로 사용 
	    (ex) if( a > b){ //수행할 문장}
-----------------------------------------------------------------------------------------------------------

4.논리연산자: 비교연산자와 마찬가지로 선택문의 조건식에 주로 사용
	-&&(논리곱연산자): 두개의 조건식을 모두 만족하냐 – Y) true , N) false
	-||(논리합연산자): 둘 중 하나라도 조건식을 만족하냐 – Y)true, N) false

5.비트연산자: bit의 상태에서 수행하는 연산자 – 결과는 0 아니면 1 인 2진수 상태
	- &(비트곱) : 2개의 비트 모두 1 => 1, 그렇지 않으면 0
	- |(비트합): 2개의 비트 중 하나라도 1 => 1. 그렇지 않으면 0
	- ^(비트차): 2개의 비트가 서로 다르냐? 다르다 1, 같다 0 == 자석

-	X    Y      x&y      x|y        x^y
-	0    0       0        0          0
-	0    1       0        1          1
-	1    0       0        1          1
-	1    1       1        1          0
*비트연산자 중 &, |은 논리연산자로도 사용가능하다.
	-차이점: 논리연산자의 &&는 앞에 조건식이 false이면 더 이상 조건 따지지 x --> false를 반환
		반대로 ||는 앞에 조건식이 true라면 – true 그래서 쟤네를 shortcut operator라고도함
		비트연산자는 무조건 조건식 다 실행해본다.

*비트 이동연산자 (= shift 연산자)
	: 비트의 상태에서 각각의 비트를 이동시키는 연산자
	- <<: 비트를 왼쪽으로 이동시키는 연산자 == *2한 결과가 됨
	- >>: 비트를 오른쪽으로 이동시키는 연산자 == /2한 결과가됨
	- >>> : int의 표현범위 내의 값으로 무조건 양수가 나오게 함
	Ex) 
		0 0 0 0 1 0 0(2) -> 4
		0 0 0 1 0 0 0(2) -> 8 // <<
		0 0 1 0 0 0 0(2) -> 16 // <<
		0 0 0 1 0 0 0(2) -> 8 // >>

*정수 표현범위 안의 수 뽑기 = Random class 사용 -> nextInt()
====================================================================================================================

삼항연산자 == 조건식 연산자
	(항 1)? 항2 : 항3 
	항1 = 조건식 
		-true이면 항2 수행, 
			-false이면 항3 수행

복합 치환연산자
	+=
	-=
	*=
	/+
	%=
	>>=
	<<=	
=======================================================================================================================

<오류의 종류>
	1. 문법 오류
	 -자바 문법 규칙에 맞지 않는 오류
	 - 컴파일이 되지 않음
	 - 컴파일 시에 오류 메세지 출력 -->오류메세지를 해결해야지만 컴파일 할 수 있다.

	2.논리오류
	 - 자바문법은 올바르지만 논리적사고를 잘못해서 프로그램이 원하는 대로 동작하지 않는 오류 --> "버그"가 발생했다.
	 * 버그를 해결하는 과정을 "디버깅"한다 라고 말함

	3.실행오류
	 -자바문법도 올바르고 논리적사고도 잘해 잘 실행되는 프로그램이 사용자의 부주의로 인하여 생기는 오류
	 - 예외처리를 통하여 문제 해결
	ex) 정수형 변수에 실수 값을 입력했다.
=======================================================================

<이름작성의 규칙> --클래스이름, 메서드이름, 변수이름

	*공통적으로 지켜야할 규칙
	 
	 -이름의 첫글자는 영문이거나 "_", "$" 기호만 사용가능 
	   but, 특별한 경우아니라면 영문으로 시작하자
	 
	 - 이름은 의미있게작성
	 
	 -두개 단어이상을 합쳐야 할 경우에는 두번째 단어 이후 시작하는 첫 글자 -> "대"문자
	 
	 - 이름에는 공백문자가 포함될 수 없음 -> 폴더명도 최대한 공백문자 x

	*클래스이름
	 
	 -이름의 첫글자는 "대"문자로 시작

	*메서드이름, 변수이름
	
	 -이름의 첫글자는 "소"문자로 시작
================================================================
<주석문>
 
 - 프로그램의 실행에 영향을 끼치지 않고 설명만을 위해 존재하는 문장
 
 - 논리오류를 제거하기 위한 디버깅을 할 때에도 의심되는 코드를 주석문 처리해가며 활용할 수 있다.
 
	 1)한줄 주석 //
	   -시작부터 그 줄 끝까지는 주석문으로 처리
	 
	 2)여러줄 주석 /*    
		안의 문장은 전부 주석처리
			  */
=============================================================

<제어문>
 - 프로그램의 흐름을 제어하는 문장들
  1.선택문
  2. 반복문
  3. break, continue
---------------------------------------------------------------------------------------------------------
 1.선택문
  -프로그램의 상황 혹은 흐름 에따라 실행시키고자 하는 문장을 달리하고 싶을 때 사용
  1__1. if문
  1__2. switch case문

 1__1. if문
  -조건식에 따라 실행시키고자 하는 문장을 "선택"할 때 사용
  - 조건식이 참일 때 실행 시키는 문장, 거짓일 때 실행시키는 문장 달리할 수 있다.
  - if의 조건식이 참이라면 else문은 pass!하고 밑에 소스코드 실행
  - 실행할 명령어가 두가지 이상이라면 반드시 "중괄호{}"로 묶어주어야함
  - else문은 생략이가능하다.

<< if 문을 사용하는 기본 형식 >>

	if (  조건식  )
		조건식이 참일때에 실행할 명령어;
	else
		조건식이 거짓일때 실행할 명령어;
=========================================================================================
class SeasonName
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		int month;
		String name;
		System.out.print("월을 입력하세요==>");
		month = sc.nextInt();
		if(month >= 3 &&   month <= 5){
			name = "봄";
		}else if( month >= 6 && month <= 8  ){
			name  = "여름";
		}else if( month >= 9 && month <= 11){
			name = "가을";
		}else if( month == 1 || month == 2 || month == 12){
			name = "겨울";
		}

		System.out.println(month + "월은 " + name + "입니다.");
	}
}
 
 *error!
	C:\javaStudy\day0930>javac SeasonName.java
	SeasonName.java:21: error: variable name might not have been initialized
                System.out.println(month + "월은 " + name + "입니다.");
                                                   ^
	1 error

 이유) String 변수를 선언해주고 초기화를 안해주었을 때, 그 변수는 비어있는 상태임.
        if문의 조건식이 다 거짓이었을 때의 else문이 없고 바로 화면출력으로 넘어가는데 이 때 변수 name은 아무런 값도 취하고 있지 않음! --> error발생요인
        error를 없애기 위해서는 String타입의 변수 선언시 미리 " " 으로 초기화 시켜준다 
===================================================================================================================
<switch 문>
 -판단해야할  경우의 수가 여러가지 인 경우, if문보다 좀 더 간결하게 문장을 표현할 수 있다.

<<switch case문의 형식>>
	
	switch(data){
		case 값1: 명령1;
		case 값2: 명령2;
		case 값3: 명령3;
		...
		case 값n: 명령n;
		default:명령k
	}

1. data에 올 수 있는 것은 "정수형 변수" 이거나 "수식의 결과가 정수"여야함
2. case 문에 break가 없다면 해당하는 case문에서부터 끝까지 실행된다. --> break 적절한 위치에 둬야함

*switch문도 if문 처럼 중첩사용이 가능하고 if문으로도 표현할 수 있다. 
*if문 또한 switch문을 안에 사용할 수 있음
------------------------------------------------------------------------------------------------------------------

2.반복문
 주어진 조건을 만족하는 동안에 주어진 명령어(들)을 반복 실행시키기위한 문장

<for 문의 형식>
	 for( 초기값; 조건식; 증감식) 
	{ 
	    // 조건식을 만족하는 동안에 실행되는 문장
	 }

	ex) for (int i = 1; i < 10; i++) // ; 은 생략불가
	     {
		sum += i
	      }
	  1. i = 1 부터 시작
	  2. sum = sum + 1
	  3. i++ -> i = 2
	  4. 조건식 확인 -> 2 < 10
	  5. 만족하니깐 다시 2번으로 감
	  6.  .....i = 9까지 실행
	  7. i++ -> i = 10
	  8. 조건식확인 -? 10 < 10
	  9. 조건식 만족하지 않으니 {} 밖으로 나가 본래 명령흐름대로 명령 실행

  if) {} 밖에서 i를 출력할 수 없다, 출력할려면 i를 for문 밖에서 선언해야함. 
  if) 밖에서 i를 선언하고 {}밖에서 i를 출력한다면 i = 10

  * 반복문 밖에서 선언한 변수이름은 반복문 안에서 선언한 변수이름이 될 수 없다.
    but, 반복문 안에서 선언한 변수이름은 중복해서 이름을 사용할 수 있다. 
           -- 반복문 안 변수는 반복문 안에서만 살아있다.
-----------------------------------------------------------------------------------------------------------

<break 와 continue>

1_break : switch문이나 반복문에서
            특정조건을 만족할 때 {}중괄호를 나가는 용도
            --자신이 속한 반복문을 빠져나온다.

2_continue : 반복문에서만 사용하며
                   특정 조건을 만나면 밑에를 건너뛰고 위로 감

			ex)
			for(int i = 1; i <= 10; i++) {
				if(i % 2 == 0) {
				      continue;
				} // 2의 배수를 제외하고 화면 출력
				System.out.println(i);
			}

<무한반복>
for( ; ;){ //실행할 명렁어(들)}
-- ()안은 계속 true가 되어서 {}안의 명령어(들)을 계속 실행함

-무한반복을 종료시키기위해서는
  for문이 오기전에 변수를 초기화시켜주고
  for문 안에 조건식을 두고
  조건식 안에 선언해둔 변수를 증감식을 사용해 만족시키면 종료가됨 -- break문 이용

ex) 
   int i = 0
   for( ; ;){
     System.out.println("Hi");
     if( i > 2 ){ //i가 2보다 크다면 break실행
         break;
      }
      i++
   }
 --------------------------------------------
 Hi
 Hi
 Hi
 i = 3이 되고 break문을 통하여
 속해있는 { }를 탈출한다.
========================================================
<while 문 >
  변수초기화
  while(조건식){
    반복실행할 명령어(들)
    증감식
   }

ex)
int i = 0;
while( i < 2){ // i가 2보다 작을동안에 {}안을 실행한다
  System.out.println("hi");
  i++;
}
------------------------------------------------
Hi //i =0
Hi //i=1
Hi //i=2
//i=3 종료
==========================================================

<do while 문>
 변수초기화
 do{
    반복실행할 명령어(들)
    증감식
   }while(조건식);

do를 만나면 {}안 한번 실행,
그러고 난 뒤 while의 조건식이 true인지 확인
true이면 {}실행, false이면 반복문 종료
while()뒤에는 ;을 항상 적어준다.

=========================================================

<while문과 do while의 차이>
while문: 
while을 만나면 조건식을 확인하고 난 뒤에
{ }안의 명령어(들)을 실행시킴

do-while문:
do를 만나고 {}을 실행한 뒤에 
while문의 조건식을 확인한다.


<반복문 정리>
반복문 : for문, while문, do-while문이 있다.

반복횟수가 정해져 있다면 
"for문"을 많이 씀
사용자의 입력값(혹은 조건이)만족할 동안 "계속" 실행해야하는 경우
while이나 do-while문을 일반적으로 사용

무조건 한번은 실행해야한다면
do-while문을 사용
===========================================================================

<배열>

 배열 : 
         같은 타입의 데이터들을 칸이 나뉘어있는 보관함에 넣어둔 것
	이때 보관함의 타입 = 데이터들의 타입이어야 보관 가능

	 ex) int[] age = new int[5];

     *[]는 데이터들을 담을 칸이 나뉜 큰 정리함? -- 칸은 0부터 시작함 (칸 : 인덱스)
     *new int[5] --칸이 나뉜 큰 정리함을 5칸으로 나눌 것이다.
     
      age[0] = 27;
     *age라는 큰 정리함의 0번째 칸에 정수값 27을 담을 것이다 -- age: 정수형 데이터를 담는 큰 정리함 -> int[] age로 위에서 선언함

	ex) int[] age = {27, 25, 24, 20, 21}; 
	//변수를 선엄함과 동시에 각 칸에 값을 초기화 시켜줌 -- 칸의 개수는 정해지지 않음, 초기화한 만큼 칸이 늘어남 (배열의 크기가 커짐)

	ex)
	int[] a = new int[5]
	-정수형 보관함 a는 5개의 칸을 갖는다

	int[] a; //정수형 보관함 a를 만듦
	-담을 수 있는 보관함을 만든 것이지 몇칸으로 나뉠지 모르니 a를 갖다 쓸 수 없음
	a = new int[5];//보관함 a를 5칸으로 만들어줌
	--칸을 만들어주는 동시에 각 칸에는 해당타입의 기본값을 넣어줌

	 int[] a = {10,20,30,40,50}
	 --보관함 a의 첫번째 칸에 10을 넣고
	   두번째칸에는 20을 넣는다...
	   총 5개의 칸이 만들어짐
----------------------------------------------------------------------------------

	<배열의 요소만큼 반복 실행하기>
1.for, while, do - while
 변수를 증감시키고
 배열의 길이보다 작을 동안이라는 조건식을 걸어
 변수를 인덱스로 이용하여 배열의 요소에 접근

2.for each 반복문
for(  자료형 변수명 :  배열이름 ){
	반복실행시킬 명령어(들)
}
* 배열의 요소를 차례대로 꺼내와 변수에 담는다.

* 자료형 변수명
   배열 변수의 타입 = 변수의 타입
* 콜론(:)을 적어준다
* 위에 선언된 배열의 이름을 적어준다
*실행순서
 1.배열이름을 통해 해당 배열의 인덱스에 접근 (0부터)
 2.자료형 변수명에 해당 배열인덱스에 저장된 값을 변수에 저장
 3.명령어 실행
 1-2-3을 배열의 마지막 인덱스값까지 반복

---------------------------------------------------------------------------------
<다차원 배열>

1)일차원 배열
   int[] a = new int[5]

2)이차원 배열
   int[][] a = new int[4][5]
  -- 4행 5열의 보관함이 생긴것
     총 20개의 데이터를 저장할 수 있는 공간이 생긴 것
     
     배열을 일괄처리하고자 한다면,
     중첩 반복문을 이용해야함.
     행을 위한 반복문 1개, 그 안에 열을 위한 반복문 1개

     행의 길이: a.length, 열의 길이: a[해당행].length
     
3)삼차원 배열
  int[][][] a = new int[2][4][5]
 -- 큰 보관함을 일단 2개의 면으로 나누고
    각각 4행 5열로 나눈다.
----------------------------------------------------------------------------------
<배열의 단점>

1. 보관함의 타입(자료형) = 안의 데이터들의 타입
2. 크기가 고정되어 있음
eX) 
   int[] a = new int[5];
   5칸만을 가진 보관함, 이후에 더 넣을 수 없다.
   --몇개를 담아야할지 예측하기 어려운 경우 배열 사용 불편
     어떤 데이터들을 담을지 모르면 배열 사용 불편

<컬렉션 프레임워크>
-배열의 단점을 보완하기 위한 "향상된 배열"
----------------------------------------------------------------------------------
<메서드>
-특정 작업을 수행하는 일련의 문장들을 하나로 묶어 이름을 붙혀준 것
-메서드의 이름을 입력하면 메서드 안의 작업들을 사용할 수 있다.

* 반환타입 메서드이름(매개변수){
   //수행해야하는 작업들
  } // 매개변수는 배열을 가진 변수도 들어갈 수 있음

-메서드의 이름을 불러서
 메서드 안의 작업을 수행하고난뒤에는
 메서드의 이름을 불렀던 곳으로 돌아간다.

if)메서드 안의 작업을 다 끝내기 전에 
   되돌아 가게하기위한 명령어: return
   return을 만나면 호출한 곳으로 돌아감

-모든 메서드는 {}안에 return을 가지고 있음.
 {}안에 안 적혀있으면 }끝나기 직전에 return이 생략된 것
 생략된 경우는 {}안에서 호출한 곳으로 돌아갈 때 값을 안들고 가도 되는 경우 -- 반환타입은 void
 return이 있는 경우는 어떤 값을 들고 돌아가야할경우 return 가지고 갈 데이터
 가지고갈 데이터의 타입 = 반환타입 이어야한다.


-메서드 호출

1)static이 없다면
  객체를 생성해 놓고 해당 객체를 통해서 메서드를 호출

2)static이 있다면
  객체 생성없이 클래스이름을 통해서 메서드 호출

-하나의 파일 안에
 두개 이상의 클래스가 존재한다면
 메인메서드를 포함하는 클래스이름 = 파일명

  
  <char 와 int>

-char
:문자를 저장하고있는 자료형
 각 문자마다 정해진 정수값이 있어
 int로 형변환을 하면 문자의 정수값을 가져온다.

 각 문자마다 정해진 정수값 = "아스키코드 값"
 ex) 다음 문자로 갈수록 1씩 증가한다.
 'a' = 97 , 'b' = 98
 'A' = 65, 'B' = 66

  char의 형변환
  1) 자동형변환
     문자형 자료형에 연산을 실행하면 정수값으로 변환
	Ex)
	  char a = 'a'
	  System.out.print( a + 1) // 97+1인 98이 출력
  2) 수동형변환
     (int)문자형 변수값을 지닌 변수명

	반대로, int형을 문자형으로 형변환하면 문자가 출력
	  ex) int k = 65;
	      System.out.print((char)k); // 'A' 출력
=========================================================================================
<객체와 클래스>

클래스 :
      "사용자 정의 자료형" //참조형
      사용자가 임의로
      변수(속성)와 메서드(기능)를 한 세트로 묶어 놓은 것
      여러가지 변수들과 메서드들로 구성될 수 있다.

*객체참조변수:
	   기본자료형 변수와 달리 선언과 동시에 값을 저장할 수 없다.
	   반드시! 객체참조변수를 통해서 "new 연산자"를 이용하여 객체를 생성하고 사용할 수 있다.
	   객체참조변수를 객체에 연결하고 그 참조변수를 통해서 멤버변수를 사용할 수 있다.

		ex) 
		   class Student{
			String name;
			String class;
		   }
		   class Main{
			Student sd = new Student(); //Student 타입의 sd 객체참조변수를 만듦, 이것은 새롭게 생성된 Student 클래스를 가리키고있다.
			sd.name = "홍길동"; //객체참조변수 sd가 가리키고있는 Student안의 nane이라는 멤버변수에 접근하여 "홍길동"이라는 데이터를 저장시킴

			*객체참조변수.멤버변수
			 .을 멤버접근연산자라고 한다.
		   
		   }
		
		ex) "배열"의 경우
		     Student[] arr = new Student[5]; 
		     // Student타입의 배열 arr를 만들고
		     // Student타입의 데이터를 저장할 공간 5개를 만듦 (arr[1], arr[2]....arr[4])
		     arr[0] = new Student();
		     //Student 타입의 arr[0](배열의 0번째 요소)가 새로운 Student 클래스를 가리키게 함
		     arr[0].name = "홍길동"
		     //배열의 0번째 요소가 가리키고 있는 Student 클래스 안 name이라는 멤버변수에 "홍길동"이라는 데이터를 저장함

================================================================================================================
<객체지향 프로그래밍>
== Object Oriented Programming (OOP)

-현실세계에 있는 모든 것을 객체화 할 수 있다.
 형체가 있는 것일 수도 있고 눈에 보이지 않는 개념적인 것일 수도 있다.
 ex) 형체있는것-컵, 개념적인 것-마신다 

-객체 :
	이 세상에서 단 하나 밖에 없는 유일한 것
	ex) 내 "핸드폰"
	    //핸드폰이라는 것은 많지만 내 핸드폰은 세상에서 단 하나 밖에 없는 유일한 것
	객체들은 객체를 구성하기 위한
	다양한 속성들로 구성되어 있고
	어떠한 객체들을 기능할 수 있다.

	이러한 다양한 속성과 기능을 지닌 객체를 만들기 위해서는
	객체의 설계도가 필요한데
	그것을 "클래스"라고 한다.
	객체는
	설계도(클래스)에 정의된 대로 생성되며
	객체를 만들기 위해서는 설계도(클래스)가 반드시 필요하다.
	
	객체의 설계도라 볼 수 있는 "클래스"는
	사용자가 새롭게 만드는 "자료형"이라 생각하면된다.

	클래스를 만들 때에는
	내가 표현해야하는 객체에 대하여
	"속성"과 "동작"을 먼저 분석하여 설계해야한다.
	이때,
	"속성" - 멤버변수
	"동작" - 멤버메서드 라고 한다.
--------------------------------------------------------------------------------------------------------------------------
<객체지향 프로그래밍의 특징>
 1) 은닉성
 	객체를 구성하고 있는 속성(변수)들은
	대체로 외부에 노출되지 않도록 만들어야 한다.

	권한이 있는 메서드 만이 속성에 접근하도록 만드는 것이 일반적

	모든 변수와 메서드를 감추고 있으면
	클래스 자체를 사용할 수 없으니
	어떤 것은 감추고, 어떤 것은 아무나 다 사용하게만들어라
	라고 지정해주는 "접근명시자"가 존재한다

	*접근명시자의 종류
	 
	 1)private:
	   외부로 노출하지 않을 때 사용
	 
	 2)public:
	   아무나 다 사용해도 좋을 때 사용

	 일반적으로 클래스를 만들 때
	 속성인 멤버변수들을 private로 두고
	 동작인 멤버메서드들은 public으로 두어 만듦

	 그래서
	 private에 있는 멤버변수에 직접 접근 할 수 없고
	 접근하는 메소드를 만들어 줌

	 접근해서 멤버에 값을 변경하는 메서드는
	   set~라고 만들고 // set = setter(설정자)
	 접근해서 멤버의 값을 읽어오는 메서드는
	   get~라고 만드는 것이 일반적이다. //get = getter(접근자)


          



